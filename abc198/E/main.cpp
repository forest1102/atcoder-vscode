#include <bits/stdc++.h>
using namespace std;
#define FOR(i, l, r) for(size_t i = (l); i < (r); ++i)
#define rep(i, n) for(int i = 0; i < (int)(n); i++)
#define rrep(i, n) for(int i = (n)-1; i >= 0; --i)
#define rfor(v, vec) for(auto &v : (vec))
#define itrloop(itr, begin, end) for(auto itr = (begin); itr != end; ++itr)
#define crfor(v, vec) for(const auto &v : (vec))
#define all(x) x.begin(), x.end()
#define call(x) x.cbegin(), x.cend()
#define rall(x) x.rbegin(), x.rend()
#define ull unsigned long long
#define ll long long
#define ul unsigned long

const long long INF = 100100100;

// const long long INF = 1LL << 60;

template < typename T > struct Edge {
    int to;
    T cost;
};

// Dijkstra
template < typename T > class Dijkstra {
  private:
    vector< vector< Edge< T > > > G;
    int num_v;

  public:
    Dijkstra(long long num_v) : G(num_v), num_v(num_v) {}

    void add_edge(int from, int to, T cost) {
        G[from].push_back((Edge< T >){to, cost});
    }

    // start: Start point
    // result: result
    void solve(int start, vector< T > &result) {
        vector< int > tmp;
        solve(start, result, tmp);
    }

    void solve(int start, vector< T > &result, vector< T > &prev) {
        result.resize(num_v);
        std::fill(result.begin(), result.end(), INF);

        prev.resize(num_v);
        std::fill(prev.begin(), prev.end(), -1);

        // get<0>(T): cost
        // get<1>(T): index
        // get<2>(T): ... ( for extent)
        using Tup = tuple< T, int >;
        priority_queue< Tup, vector< Tup >, greater< Tup > > que;

        que.emplace(0, start);
        result[start] = 0;

        while(!que.empty()) {
            Tup p = que.top();
            que.pop();

            T t = get< 0 >(p);
            int v = get< 1 >(p);

            // queueに入れてから別の最短経路が見つかった場合、探索処理は不要
            if(result[v] != t) {
                continue;
            }

            // vの各辺に対しよりコストの低い経路があるかを確認
            for(auto &e : G[v]) {
                if(result[e.to] > result[v] + e.cost) {
                    prev[e.to] = v;
                    result[e.to] = result[v] + e.cost;
                    que.emplace(result[v] + e.cost, e.to);
                }
            }
        }
    }

    // t: 目的地
    vector< T > get_path(const vector< T > &prev, int t) {
        vector< T > path;

        for(int v = t; v != -1; v = prev[v]) {
            path.push_back(v);
        }

        // reverse(path.begin(), path.end());
        return path;
    }
};

// Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips:
// You use the default template now. You can remove this line by using your
// custom template)
int main() {
    long long N;
    scanf("%lld", &N);
    std::vector< long long > C(N);
    for(int i = 0; i < N; i++) {
        scanf("%lld", &C[i]);
    }
    Dijkstra< ll > g(N);
    for(int i = 0; i < N - 1; i++) {
        ll a, b;
        scanf("%lld %lld", &a, &b);
        g.add_edge(a - 1, b - 1, 1);
        g.add_edge(b - 1, a - 1, 1);
    }
    vector< ll > res, prev;
    g.solve(0, res, prev);

    rep(i, N) {
        auto path = g.get_path(prev, i);
        bool good_v = true;
        FOR(i, 1, path.size()) {
            auto p = path[i];
            auto c = C[p];
            if(c != C[i]) {
                good_v = false;
                break;
            }
        }
        if(good_v)
            cout << i + 1 << endl;
    }

    return 0;
}
